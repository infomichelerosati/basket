<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<!-- Aggiunto viewport-fit=cover per gestire il notch e le barre di sistema iOS -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Dunk Shot Master</title>
<style>
    body, html {
        margin: 0;
        padding: 0;
        width: 100%;
        /* Usa dvh (dynamic viewport height) per iOS, fallback a 100% */
        height: 100%;
        height: 100dvh; 
        background-color: #0b0e14;
        overflow: hidden;
        /* Disabilita zoom e scroll nativi */
        touch-action: none;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    #gameCanvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
        background: radial-gradient(circle at center, #1b2735 0%, #090a0f 100%);
    }
    #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 10;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        /* Padding extra per evitare il notch su iPhone */
        padding-top: max(20px, env(safe-area-inset-top)); 
    }
    .score-container {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
        gap: 20px;
        background: rgba(11, 14, 20, 0.7);
        padding: 8px 30px;
        border-radius: 50px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(8px);
        box-shadow: 0 4px 15px rgba(0,0,0,0.4);
    }
    .score-text {
        font-size: 36px;
        font-weight: 900;
        color: white;
        text-shadow: 0 0 10px rgba(255, 94, 0, 0.6);
        margin: 0;
        line-height: 1;
    }
    .lives-text {
        font-size: 18px;
        color: #ff2d75;
        margin: 0;
        letter-spacing: 2px;
        filter: drop-shadow(0 0 5px rgba(255, 45, 117, 0.6));
    }
    .best-text {
        font-size: 12px;
        color: rgba(255,255,255,0.6);
        text-transform: uppercase;
        letter-spacing: 1px;
        margin: 0;
        font-weight: 600;
        border-left: 1px solid rgba(255,255,255,0.2);
        padding-left: 15px;
    }
    .wind-indicator {
        margin-top: 10px;
        font-size: 14px;
        color: #00f2ff;
        font-weight: bold;
        text-transform: uppercase;
        opacity: 0;
        transition: opacity 0.5s;
        text-shadow: 0 0 5px #00f2ff;
    }
    .pop-text {
        position: absolute;
        color: #00f2ff;
        font-weight: 900;
        font-size: 28px;
        font-style: italic;
        opacity: 0;
        text-shadow: 0 0 10px rgba(0, 242, 255, 0.8);
        transform: translateY(0);
        animation: floatUp 1s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        z-index: 20;
    }
    .warning-text {
        position: absolute;
        top: 35%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        font-size: 42px;
        font-weight: 900;
        color: #ff00de;
        text-shadow: 2px 2px 0px #000, 0 0 20px #ff00de, 0 0 40px white;
        white-space: nowrap;
        text-transform: uppercase;
        font-style: italic;
        z-index: 100;
        pointer-events: none;
        text-align: center;
        animation: warnPop 4s linear forwards;
    }
    @keyframes warnPop {
        0% { transform: translate(-50%, -50%) scale(0) rotate(-15deg); opacity: 0; filter: blur(10px); }
        5% { transform: translate(-50%, -50%) scale(1.1) rotate(0deg); opacity: 1; filter: blur(0px); }
        10% { transform: translate(-50%, -50%) scale(1); }
        50% { transform: translate(-50%, -50%) scale(1.05); }
        90% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        100% { transform: translate(-50%, -50%) scale(1.5) translateY(-50px); opacity: 0; filter: blur(10px); }
    }
    @keyframes floatUp {
        0% { opacity: 0; transform: translateY(20px) scale(0.5); }
        20% { opacity: 1; transform: translateY(0) scale(1.2); }
        100% { opacity: 0; transform: translateY(-80px) scale(1); }
    }
</style>
</head>
<body>

<div id="ui-layer">
    <div class="score-container">
        <div id="score" class="score-text">0</div>
        <div id="lives" class="lives-text">❤❤❤</div>
        <div id="best" class="best-text">Best: 0</div>
    </div>
    <div id="wind" class="wind-indicator">WIND >></div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const bestEl = document.getElementById('best');
    const windEl = document.getElementById('wind');
    const uiLayer = document.getElementById('ui-layer');

    let width, height;
    let score = 0, bestScore = 0;
    let lives = 3;
    let cameraY = 0, targetCameraY = 0;
    let gameState = 'START'; 
    let windForce = 0; 

    const THEME = {
        bg: '#0b0e14',
        ball: '#ff9500',
        ballFire: '#ff4400',
        rim: '#ff2d75',
        rimDark: '#a60038',
        backboard: 'rgba(0, 242, 255, 0.1)',
        backboardBorder: 'rgba(0, 242, 255, 0.5)',
        net: 'rgba(255, 255, 255, 0.5)',
        star: 'rgba(255, 255, 255, 0.3)',
        traj: 'rgba(255, 255, 255, 0.4)',
        obstacle: '#00f2ff',
        blocker: '#ff0044'
    };

    let ball = { x: 0, y: 0, r: 18, vx: 0, vy: 0, rot: 0, rimHit: false, stuckTimer: 0 };
    let hoops = [];
    let obstacles = [];
    let particles = [];
    let stars = []; 
    let drag = { active: false, x: 0, y: 0, startX: 0, startY: 0 };
    let isPerfectStreak = 0;
    let basketStreak = 0; 
    let lastSafeHoop = null; 
    let gameTime = 0; 

    // Flags per gli avvisi
    let seenFeatures = {
        movement: false,
        wave: false,
        blockers: false,
        small: false
    };

    // FIX per iOS: ricalcolo dimensioni forzato e gestione resize
    function resize() {
        // Usa documentElement.clientHeight se window.innerHeight non è affidabile
        width = window.innerWidth;
        height = window.innerHeight; 
        
        canvas.width = width;
        canvas.height = height;
        
        if (stars.length === 0) initStars();
        if (hoops.length === 0) resetLevel();
    }

    function initStars() {
        stars = [];
        const numStars = 150;
        for(let i=0; i<numStars; i++) {
            stars.push({
                x: Math.random() * width,
                y: Math.random() * height,
                size: Math.random() * 2 + 0.5,
                baseAlpha: Math.random() * 0.5 + 0.3,
                alpha: Math.random(),
                speed: Math.random() * 0.5 + 0.1,
                twinkle: Math.random() * 0.02
            });
        }
    }

    function showWarning(text, color) {
        const el = document.createElement('div');
        el.className = 'warning-text';
        el.innerText = text;
        if(color) el.style.color = color;
        uiLayer.appendChild(el);
        setTimeout(() => el.remove(), 4000);
    }

    function createHoop(y, side) {
        let xPos = width / 2;
        if (side === -1) xPos = width * 0.25;
        if (side === 1) xPos = width * 0.75;

        // DIFFICOLTÀ PROGRESSIVA
        let movementType = 'STATIC';
        let moveSpeedX = 0;
        let moveSpeedY = 0;
        let hoopWidth = 90;
        let blockers = [];

        // Livello 1: Movimento orizzontale
        if (score > 5) {
            movementType = 'HORIZONTAL';
            moveSpeedX = (Math.random() > 0.5 ? 1 : -1) * (1 + score * 0.05);
            if (!seenFeatures.movement) {
                seenFeatures.movement = true;
                showWarning("BERSAGLI MOBILI!", "#00f2ff");
            }
        }
        
        // Livello 2: Movimento Verticale/Onda
        if (score > 15 && Math.random() > 0.5) {
            movementType = 'WAVE';
            moveSpeedX = (Math.random() > 0.5 ? 1.5 : -1.5);
            moveSpeedY = 0.05; 
            if (!seenFeatures.wave) {
                seenFeatures.wave = true;
                showWarning("ONDA SISMICA!", "#bd00ff");
            }
        }

        // Livello 3: Canestri più piccoli
        if (score > 20) {
            hoopWidth = 80;
            if (!seenFeatures.small) {
                seenFeatures.small = true;
                showWarning("CERCHI STRETTI!", "#ff9500");
            }
        }

        // Livello 4: Droni Difensivi
        if (score > 10 && Math.random() < Math.min(0.8, (score-10)*0.05)) {
            let count = (score > 25 && Math.random() > 0.5) ? 2 : 1;
            for(let i=0; i<count; i++) {
                blockers.push({
                    angle: (Math.PI * 2 * i) / count,
                    speed: 0.03 + (Math.random() * 0.02),
                    dist: 70, 
                    r: 8
                });
            }
            if (!seenFeatures.blockers) {
                seenFeatures.blockers = true;
                showWarning("DRONI DIFENSIVI!", "#ff0044");
            }
        }

        return {
            x: xPos,
            y: y,
            w: hoopWidth,
            scored: false,
            side: side,
            startX: xPos,
            startY: y,
            movementType: movementType,
            moveSpeedX: moveSpeedX,
            moveSpeedY: moveSpeedY,
            swish: 0,
            blockers: blockers,
            timeOffset: Math.random() * 100
        };
    }

    function createObstacle(y) {
        return {
            x: width / 2 - 40,
            y: y - 180,
            w: 80,
            h: 15,
            vx: Math.random() > 0.5 ? 2.5 : -2.5,
            type: 'moving_horiz' 
        };
    }

    function setWind() {
        if (score > 8 && Math.random() > 0.6) {
            windForce = (Math.random() - 0.5) * 0.08; 
            let dir = windForce > 0 ? ">>" : "<<";
            windEl.innerText = `VENTO ${dir}`;
            windEl.style.opacity = 1;
            showWarning("ALLARME VENTO!", "#00ffea");
        } else {
            windForce = 0;
            windEl.style.opacity = 0;
        }
    }

    function spawnParticles(x, y, count, color) {
        for (let i = 0; i < count; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 1.0,
                color: color || '#fff',
                size: Math.random() * 4 + 1
            });
        }
    }

    function showFloatingText(text, x, y, color) {
        const el = document.createElement('div');
        el.className = 'pop-text';
        el.innerText = text;
        if(color) el.style.color = color;
        const screenY = y - cameraY;
        let screenX = Math.max(50, Math.min(width - 50, x));
        el.style.left = screenX + 'px';
        el.style.top = screenY + 'px';
        uiLayer.appendChild(el);
        setTimeout(() => el.remove(), 1000);
    }

    function updateLivesUI() {
        let hearts = '';
        let displayLives = Math.min(lives, 5);
        for(let i=0; i<displayLives; i++) hearts += '❤';
        if (lives > 5) hearts += '+';
        livesEl.innerText = hearts;
    }

    function resetLevel() {
        score = 0;
        isPerfectStreak = 0;
        basketStreak = 0; 
        lives = 3;
        windForce = 0;
        seenFeatures = { movement: false, wave: false, blockers: false, small: false };
        
        updateLivesUI();
        windEl.style.opacity = 0;
        scoreEl.innerText = score;
        scoreEl.style.color = 'white';
        cameraY = 0;
        targetCameraY = 0;
        hoops = [];
        obstacles = [];
        particles = [];
        initStars();

        // FIX iOS: Alzato il canestro iniziale al 70% invece del 75% per evitare la barra inferiore
        let startY = height * 0.70;
        let h1 = createHoop(startY, 0);
        h1.scored = true;
        hoops.push(h1);
        lastSafeHoop = h1; 

        addNextHoop();
        resetBall(h1);
        gameState = 'START';
    }

    function addNextHoop() {
        let lastHoop = hoops[hoops.length - 1];
        let newY = lastHoop.y - (height * 0.4); 
        let side = Math.random() > 0.5 ? 1 : -1;
        
        if (score > 3 && Math.random() > 0.5) {
            obstacles.push(createObstacle(newY));
        }
        setWind();

        hoops.push(createHoop(newY, side));
    }

    function resetBall(hoop) {
        ball.x = hoop.x;
        ball.y = hoop.y - ball.r - 5;
        ball.vx = 0;
        ball.vy = 0;
        ball.rimHit = false;
        ball.stuckTimer = 0;
        gameState = 'START';
    }

    // --- COLLISION ---
    function resolveCircleCollision(targetX, targetY, radiusCheck) {
        let dx = ball.x - targetX;
        let dy = ball.y - targetY;
        let dist = Math.hypot(dx, dy);
        
        if (dist < ball.r + radiusCheck) {
            let nx = dx / dist;
            let ny = dy / dist;
            let penetration = (ball.r + radiusCheck) - dist;
            ball.x += nx * penetration;
            ball.y += ny * penetration;
            let dot = ball.vx * nx + ball.vy * ny;
            ball.vx = (ball.vx - 2 * dot * nx) * 0.65;
            ball.vy = (ball.vy - 2 * dot * ny) * 0.65;
            return true;
        }
        return false;
    }

    function resolveRectCollision(obs) {
        let closestX = Math.max(obs.x, Math.min(ball.x, obs.x + obs.w));
        let closestY = Math.max(obs.y, Math.min(ball.y, obs.y + obs.h));
        let dx = ball.x - closestX;
        let dy = ball.y - closestY;
        let dist = Math.hypot(dx, dy);

        if (dist < ball.r) {
            let nx, ny;
            if (dist === 0) { nx = 0; ny = -1; dist = 0.01; } 
            else { nx = dx / dist; ny = dy / dist; }
            let penetration = ball.r - dist;
            ball.x += nx * penetration;
            ball.y += ny * penetration;
            let dot = ball.vx * nx + ball.vy * ny;
            ball.vx = (ball.vx - 2 * dot * nx) * 0.8;
            ball.vy = (ball.vy - 2 * dot * ny) * 0.8;
            return true;
        }
        return false;
    }

    // --- INPUT ---
    function onInputStart(x, y) {
        if (gameState !== 'START') return;
        drag.active = true;
        drag.startX = x;
        drag.startY = y;
        drag.x = x;
        drag.y = y;
        gameState = 'AIMING';
    }

    function onInputMove(x, y) {
        if (!drag.active) return;
        drag.x = x;
        drag.y = y;
    }

    function onInputEnd() {
        if (!drag.active) return;
        drag.active = false;
        let dx = drag.startX - drag.x;
        let dy = drag.startY - drag.y;
        if (Math.hypot(dx, dy) > 20) {
            ball.vx = dx * 0.14; 
            ball.vy = dy * 0.16;
            ball.rimHit = false;
            ball.stuckTimer = 0;
            gameState = 'FLYING';
        } else {
            gameState = 'START';
        }
    }

    // Mouse Listeners
    window.addEventListener('mousedown', e => onInputStart(e.clientX, e.clientY));
    window.addEventListener('mousemove', e => onInputMove(e.clientX, e.clientY));
    window.addEventListener('mouseup', onInputEnd);
    
    // Touch Listeners (con passive: false per evitare scroll su iOS)
    window.addEventListener('touchstart', e => {
        // e.preventDefault(); // Su alcuni iOS blocca tutto, meglio rimuovere o gestire selettivamente
        onInputStart(e.touches[0].clientX, e.touches[0].clientY);
    }, {passive: false});
    
    window.addEventListener('touchmove', e => {
        e.preventDefault(); // Questo è importante per evitare lo scroll della pagina mentre miri
        onInputMove(e.touches[0].clientX, e.touches[0].clientY);
    }, {passive: false});
    
    window.addEventListener('touchend', e => {
        onInputEnd();
    });
    
    window.addEventListener('resize', resize);

    // --- UPDATE ---
    function update() {
        gameTime += 1;

        stars.forEach(s => {
            s.y += s.speed;
            if (windForce !== 0) s.x += windForce * 50; 
            if (s.x > width) s.x -= width;
            if (s.x < 0) s.x += width;
            s.alpha = s.baseAlpha + Math.sin(Date.now() * s.twinkle) * 0.2;
            if (s.y > height) s.y -= height;
        });

        hoops.forEach(h => {
            if (!h.scored) {
                if (h.movementType === 'HORIZONTAL') {
                    h.x += h.moveSpeedX;
                    if (h.x > width - 50 || h.x < 50) h.moveSpeedX *= -1;
                } else if (h.movementType === 'WAVE') {
                    h.x += h.moveSpeedX;
                    if (h.x > width - 50 || h.x < 50) h.moveSpeedX *= -1;
                    h.y = h.startY + Math.sin((gameTime + h.timeOffset) * h.moveSpeedY) * 30;
                }
            }
            if (h.swish > 0) h.swish -= 0.05;

            h.blockers.forEach(b => {
                b.angle += b.speed;
            });
        });

        obstacles.forEach(obs => {
            obs.x += obs.vx;
            if (obs.x < 0 || obs.x + obs.w > width) obs.vx *= -1;
        });

        if (gameState === 'FLYING') {
            ball.vy += 0.55; 
            ball.vx += windForce; 
            ball.x += ball.vx;
            ball.y += ball.vy;
            ball.rot += ball.vx * 0.1;

            if (Math.abs(ball.vx) < 0.2 && Math.abs(ball.vy) < 0.2) {
                ball.stuckTimer++;
                if (ball.stuckTimer > 100) { 
                    ball.vy = -5; ball.vx = (Math.random() - 0.5) * 4; ball.stuckTimer = 0;
                }
            } else { ball.stuckTimer = 0; }

            if (ball.x < ball.r) { ball.x = ball.r; ball.vx *= -0.7; }
            if (ball.x > width - ball.r) { ball.x = width - ball.r; ball.vx *= -0.7; }

            obstacles.forEach(obs => {
                if (resolveRectCollision(obs)) spawnParticles(ball.x, ball.y, 5, THEME.obstacle);
            });

            hoops.forEach(h => {
                if (h.scored) return;

                h.blockers.forEach(b => {
                    let bx = h.x + Math.cos(b.angle) * b.dist;
                    let by = h.y + Math.sin(b.angle) * b.dist;
                    if (resolveCircleCollision(bx, by, b.r)) {
                        spawnParticles(ball.x, ball.y, 10, THEME.blocker);
                    }
                });

                let rimL = h.x - h.w/2;
                let rimR = h.x + h.w/2;

                if (resolveCircleCollision(rimL, h.y, 5) || resolveCircleCollision(rimR, h.y, 5)) {
                     ball.rimHit = true;
                }

                if (ball.vy > 0 && 
                    ball.x > rimL + 10 && ball.x < rimR - 10 && 
                    ball.y > h.y && ball.y < h.y + 20) {
                    
                    h.scored = true;
                    h.swish = 1.0; 
                    lastSafeHoop = h;
                    basketStreak++;
                    
                    if (basketStreak % 3 === 0) {
                        lives++;
                        updateLivesUI();
                        showFloatingText("+1 VITA!", width/2, h.y - 100, '#00ff00');
                    }

                    let points = 1;
                    let isPerfect = !ball.rimHit;
                    
                    if (isPerfect) {
                        points = 2;
                        isPerfectStreak++;
                        showFloatingText((isPerfectStreak > 1 ? "PERFECT x" + isPerfectStreak : "PERFECT!"), width/2, h.y - 50);
                    } else { isPerfectStreak = 0; }
                    
                    score += points;
                    scoreEl.innerText = score;
                    if(isPerfectStreak > 2) scoreEl.style.color = '#ff4400';
                    else scoreEl.style.color = 'white';

                    if(score > bestScore) {
                        bestScore = score;
                        bestEl.innerText = "Best: " + bestScore;
                    }
                    
                    spawnParticles(h.x, h.y, 25, isPerfect ? '#00f2ff' : '#ffffff');
                    resetBall(h);
                    targetCameraY = h.y - (height * 0.7);
                    addNextHoop();
                }
            });

            if (ball.y > cameraY + height + 100) {
                basketStreak = 0;
                if (lives > 1) {
                    lives--;
                    updateLivesUI();
                    showFloatingText("AHIA!", width/2, cameraY + height/2, '#ff2d75');
                    if (lastSafeHoop) {
                        resetBall(lastSafeHoop);
                        targetCameraY = lastSafeHoop.y - (height * 0.7);
                    } else { resetLevel(); }
                } else { resetLevel(); }
            }
        }

        cameraY += (targetCameraY - cameraY) * 0.1;

        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx; p.y += p.vy; p.life -= 0.03;
            if (p.life <= 0) particles.splice(i, 1);
        }
    }

    function draw() {
        ctx.clearRect(0,0,width,height);

        ctx.save();
        for(let s of stars) {
            let parallaxY = -cameraY * 0.2; 
            let finalY = (s.y + parallaxY) % height;
            if (finalY < 0) finalY += height;
            ctx.fillStyle = THEME.star;
            ctx.globalAlpha = Math.max(0, Math.min(1, s.alpha));
            ctx.beginPath();
            ctx.arc(s.x, finalY, s.size, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.globalAlpha = 1.0;
        ctx.restore();

        ctx.save();
        ctx.translate(0, -cameraY);

        ctx.shadowBlur = 15;
        ctx.shadowColor = THEME.obstacle;
        ctx.fillStyle = THEME.obstacle;
        obstacles.forEach(obs => {
            ctx.beginPath();
            ctx.roundRect(obs.x, obs.y, obs.w, obs.h, 5); 
            ctx.fill();
        });
        ctx.shadowBlur = 0;

        hoops.forEach(h => {
            let xl = h.x - h.w/2;
            let xr = h.x + h.w/2;
            let bbW = h.w + 30;
            
            ctx.save();
            ctx.fillStyle = THEME.backboard;
            ctx.strokeStyle = THEME.backboardBorder;
            ctx.lineWidth = 2;
            let bbH = 80;
            ctx.beginPath();
            ctx.roundRect(h.x - bbW/2, h.y - bbH - 10, bbW, bbH, 10);
            ctx.fill();
            ctx.stroke();
            ctx.strokeStyle = "rgba(255,255,255,0.3)";
            ctx.strokeRect(h.x - 30, h.y - bbH + 30, 60, 40);
            ctx.restore();

            ctx.strokeStyle = THEME.net;
            ctx.lineWidth = 2;
            ctx.beginPath();
            let swishY = h.swish * 10;
            ctx.moveTo(xl, h.y);
            ctx.quadraticCurveTo(xl + 10, h.y + 40 + swishY, h.x, h.y + 70 + swishY);
            ctx.moveTo(xr, h.y);
            ctx.quadraticCurveTo(xr - 10, h.y + 40 + swishY, h.x, h.y + 70 + swishY);
            ctx.moveTo(xl + 20, h.y); ctx.lineTo(xr - 20, h.y + 50 + swishY);
            ctx.moveTo(xr - 20, h.y); ctx.lineTo(xl + 20, h.y + 50 + swishY);
            ctx.stroke();

            ctx.strokeStyle = THEME.rimDark;
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(xl, h.y); ctx.lineTo(xr, h.y); ctx.stroke();
            
            ctx.shadowBlur = 10;
            ctx.shadowColor = THEME.rim;
            ctx.strokeStyle = THEME.rim;
            ctx.beginPath(); ctx.moveTo(xl, h.y); ctx.lineTo(xr, h.y); ctx.stroke();
            ctx.fillStyle = THEME.rim;
            ctx.beginPath(); ctx.arc(xl, h.y, 4, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(xr, h.y, 4, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;

            h.blockers.forEach(b => {
                let bx = h.x + Math.cos(b.angle) * b.dist;
                let by = h.y + Math.sin(b.angle) * b.dist;
                ctx.fillStyle = THEME.blocker;
                ctx.shadowBlur = 10;
                ctx.shadowColor = THEME.blocker;
                ctx.beginPath();
                ctx.arc(bx, by, b.r, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });
        });

        particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
        });
        ctx.globalAlpha = 1.0;

        if (gameState === 'AIMING') {
            let dx = drag.startX - drag.x;
            let dy = drag.startY - drag.y;
            let simX = ball.x;
            let simY = ball.y;
            let simVx = dx * 0.14 + windForce; 
            let simVy = dy * 0.16;
            ctx.fillStyle = THEME.traj;
            for(let i=0; i<15; i++) {
                simVy += 0.55; simX += simVx; simY += simVy;
                ctx.beginPath(); ctx.arc(simX, simY, 4 - (i*0.2), 0, Math.PI*2); ctx.fill();
            }
        }

        ctx.translate(ball.x, ball.y);
        ctx.rotate(ball.rot);
        let ballColor = (isPerfectStreak > 2) ? THEME.ballFire : THEME.ball;
        ctx.fillStyle = ballColor;
        ctx.shadowBlur = 15;
        ctx.shadowColor = ballColor;
        ctx.beginPath(); ctx.arc(0, 0, ball.r, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
        ctx.strokeStyle = 'rgba(0,0,0,0.4)';
        ctx.lineWidth = 2.5;
        ctx.beginPath(); ctx.moveTo(-ball.r, 0); ctx.lineTo(ball.r, 0);
        ctx.moveTo(0, -ball.r); ctx.lineTo(0, ball.r); ctx.stroke();
        ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
        ctx.beginPath(); ctx.arc(-6, -6, 5, 0, Math.PI*2); ctx.fill();

        ctx.restore();
    }

    if (!ctx.roundRect) {
        ctx.roundRect = function(x, y, w, h, r) {
            if (w < 2 * r) r = w / 2; if (h < 2 * r) r = h / 2;
            this.moveTo(x+r, y);
            this.arcTo(x+w, y, x+w, y+h, r);
            this.arcTo(x+w, y+h, x, y+h, r);
            this.arcTo(x, y+h, x, y, r);
            this.arcTo(x, y, x+w, y, r);
            this.closePath();
            return this;
        }
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    resize();
    requestAnimationFrame(loop);

</script>
</body>
</html>
